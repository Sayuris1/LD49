local path = require "modules.path"
local utils = require "modules.utils"
local camera = require "orthographic.camera"

enemies = {}
current_player = 0
next_wave = 5

function notify_next(player_tile)
	current_player = current_player + 1
	if enemies[current_player] then
		msg.post(enemies[current_player], utils.pre_hash("play"), {player_tile = player_tile})
	else
		msg.post("/player#script", utils.pre_hash("play"))
	end

	local is_chest = math.random(10)
	if is_chest == 10 then
		local pos_x, pos_y = utils.tile_to_world({x = math.random(14), y = math.random(14)}, 32)
		factory.create("/player#chest_factory", vmath.vector3(pos_x, pos_y, 1))
	end

	if next_wave == 0 then
		local pos_x, pos_y = utils.tile_to_world({x = math.random(14), y = math.random(14)}, 32)
		factory.create("/player#bat_factory", vmath.vector3(pos_x, pos_y, 1))
		local pos_x, pos_y = utils.tile_to_world({x = math.random(14), y = math.random(14)}, 32)
		factory.create("/player#golem_factory", vmath.vector3(pos_x, pos_y, 1))
		next_wave = 5
	end
end

function init(self)
	math.randomseed(os.clock())

	msg.post(".", "acquire_input_focus")

	local tile_x, tile_y = utils.world_to_tile(go.get_position(), 32)
	self.current_tile = {x = tile_x, y = tile_y}

	path.setup_astar()
	path.underline_nears(self.current_tile, 4, 2, 1)

	self.knife = 5
	self.spawn = 3
end

function on_message(self, message_id, message, sender)
	if message_id == utils.pre_hash("play") then
		current_player = 0
		path.underline_nears(self.current_tile, 4, 2, 1)
	elseif message_id == utils.pre_hash("trigger_response") then
		if message.other_group == utils.pre_hash("chest") then
			self.knife = self.knife + 5
			go.delete(message.other_id)
		end
	end
end

function on_input(self, action_id, action)
	utils.cursor_update(action, action_id)

	if action.pressed and current_player == 0 then
		if action_id == utils.pre_hash("touch_2") then
			local world_pos = camera.screen_to_world(nil, vmath.vector3(action.x + 16, action.y + 16, 0))
			local clicked_tile = {}; clicked_tile.x, clicked_tile.y = utils.world_to_tile(world_pos, 32)
			if path.is_near(clicked_tile) then
				path.damage(self.current_tile, clicked_tile)
				self.current_tile = clicked_tile

				local new_pos_x, new_pos_y = utils.tile_to_world(self.current_tile, 32)
				go.set_position(vmath.vector3(new_pos_x, new_pos_y, 1))

				path.reset_underline(1)

				next_wave = next_wave - 1
				notify_next(self.current_tile)

				for i, v in ipairs(path.destroyed) do
					v.turn = v.turn - 1
					if v.turn == 0 then
						tilemap.set_tile("/map#map", "1", v.x, v.y, 1)
						table.remove(path.destroyed, i)

						path.reset_map()
					end
				end
			end

		elseif action_id == utils.pre_hash("touch") and self.knife > 0 then
			local world_pos = camera.screen_to_world(nil, vmath.vector3(action.x + 16, action.y + 16, 0))
			local clicked_tile = {}; clicked_tile.x, clicked_tile.y = utils.world_to_tile(world_pos, 32)

			local rotation, speed
			if clicked_tile.x < self.current_tile.x then
				rotation = vmath.quat_rotation_z(math.pi / 2)
				speed = vmath.vector3(-500, 0, 0)
			elseif clicked_tile.x > self.current_tile.x then
				rotation = vmath.quat_rotation_z(-math.pi / 2)
				speed = vmath.vector3(500, 0, 0)
			elseif clicked_tile.y > self.current_tile.y then
				rotation = vmath.quat_rotation_z(0)
				speed = vmath.vector3(0, 500, 0)
			else
				rotation = vmath.quat_rotation_z(math.pi)
				speed = vmath.vector3(0, -500, 0)
			end

			self.knife = self.knife - 1
			factory.create("#knife_factory", go.get_position(), rotation, {speed = speed})
		end
	end
end