local utils = require "modules.utils"
local path = require "modules.path"

function init(self)
	local tile_x, tile_y = utils.world_to_tile(go.get_position(), 32)
	self.current_tile = {x = tile_x, y = tile_y}

	self.healt = 5

	enemies[#enemies + 1] = msg.url()
end

function final(self)
	local url = msg.url()

	for i, v in ipairs(enemies) do
		if v == url then
			table.remove(enemies, i)

			return
		end
	end
end

local function check_nears(current_tile, player_tile)
	for i, tile in ipairs(path.nears[1]) do
		local distance = {}
		distance.x = tile.x - player_tile.x
		distance.y = tile.y - player_tile.y

		if math.abs(distance.x) == 0 then
			current_tile.x = tile.x
			set_pos(tile)

			return true
		elseif math.abs(distance.y) == 0 then
			current_tile.y = tile.y
			set_pos(tile)

			return true
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == utils.pre_hash("play") then
		path.underline_nears(self.current_tile, 3, 3, 1)

		if not check_nears(self.current_tile, message.player_tile) then
			local i = math.random(#path.nears[1])
			set_pos(path.nears[1][i])
		end

		path.reset_underline(1)

		notify_next(message.player_tile)

	elseif message_id == utils.pre_hash("trigger_response") then
		if message.other_group == utils.pre_hash("bullet_2") then
			self.healt = self.healt - 1
			if self.healt <= 0 then
				go.delete()
			end
		end

	elseif message_id == utils.pre_hash("cursor_over") then
		path.underline_nears(self.current_tile, 3, 3, 2)
	elseif message_id == utils.pre_hash("cursor_out") then
		path.reset_underline(2)
		for i, v in ipairs(path.nears[1]) do
            tilemap.set_tile("/map#map", "2", v.x, v.y, 2)
		end
	end
end
